<!DOCTYPE html>
<html lang="fr" x-data="midiApp()">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Piano Trainer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
    />
    <script src="https://unpkg.com/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script
      defer
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
    <style>
      .controls-row {
        display: flex;
        gap: 1rem;
        align-items: center;
        margin: 1rem 0;
      }

      .recording-status {
        color: var(--del-color);
        font-weight: bold;
      }

      .replay-status {
        color: var(--primary-color);
        font-weight: bold;
      }

      .staff-container {
        margin: 1.5rem 0;
        background-color: white;
        padding: 1rem;
        border: 1px solid var(--border-color);
        border-radius: var(--border-radius);
      }

      .btn-record {
        background-color: var(--del-color);
      }

      .btn-stop {
        background-color: var(--ins-color);
      }

      .btn-replay {
        background-color: var(--primary-color);
      }
    </style>
  </head>
  <body>
    <main class="container">
      <button
        @click="scanBluetooth"
        x-text="'Scanner Bluetooth MIDI'"
        x-show="!bluetoothConnected"
      ></button>

      <div>
        <!-- Contr√¥les d'enregistrement -->
        <div class="controls-row">
          <button
            @click="startRecording"
            x-show="!isRecording && !isReplaying && bluetoothConnected"
            class="btn-record"
          >
            üî¥ D√©marrer enregistrement
          </button>

          <button @click="stopRecording" x-show="isRecording" class="btn-stop">
            ‚èπÔ∏è Arr√™ter enregistrement
          </button>

          <span x-show="isRecording" class="recording-status">
            üî¥ Enregistrement en cours... (<span x-text="recordingDuration"
              >0</span
            >s)
          </span>
        </div>

        <!-- S√©lection et rejeu de cassettes -->
        <div class="controls-row" x-show="!isRecording">
          <select x-model="selectedCassette" @change="loadCassettesList()">
            <option value="">Choisir une cassette...</option>
            <template x-for="cassette in cassettes" :key="cassette.name">
              <option :value="cassette.file" x-text="cassette.name"></option>
            </template>
          </select>

          <button
            @click="replayCassette"
            x-show="selectedCassette && !isReplaying"
            class="btn-replay"
          >
            ‚ñ∂Ô∏è Rejouer cassette
          </button>

          <span x-show="isReplaying" class="replay-status">
            ‚ñ∂Ô∏è Rejeu en cours...
          </span>
        </div>

        <div id="staff" class="staff-container"></div>
      </div>
    </main>
    <script>
      function midiApp() {
        return {
          bluetoothConnected: false,
          device: null,
          staff: null,
          // Enregistrement
          isRecording: false,
          recordingData: [],
          recordingStartTime: null,
          recordingDuration: 0,
          recordingTimer: null,
          // Rejeu
          isReplaying: false,
          cassettes: [],
          selectedCassette: '',
          init() {
            this.initStaff()
            this.loadCassettesList()
            window.addEventListener('beforeunload', () => {
              if (this.device) this.device.gatt.disconnect()
            })
          },
          initStaff() {
            const VF = Vex.Flow
            const div = document.getElementById('staff')
            div.innerHTML = '' // Clear previous staff
            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG)
            renderer.resize(600, 200)
            const context = renderer.getContext()

            this.staff = {
              renderer,
              context,
              stave: new VF.Stave(10, 40, 580),
              notes: []
            }

            this.staff.stave.addClef('treble').addTimeSignature('4/4')
            this.staff.stave.setContext(context).draw()
          },
          addNoteToStaff(noteName) {
            console.log('Adding note to staff:', noteName)
            // Convert note name (like "C3") to VexFlow format
            const vexNote = this.convertToVexFlowNote(noteName)
            this.staff.notes.push(vexNote)
            console.log('Current staff notes:', this.staff.notes)

            // Keep only last 8 notes to fit on staff
            if (this.staff.notes.length > 8) {
              this.staff.notes.shift()
            }

            this.redrawStaff()
          },
          convertToVexFlowNote(noteName) {
            // Convert "C#4" to VexFlow format
            const isSharp = noteName.includes('#')
            let note = noteName.replace('#', '').slice(0, -1).toLowerCase() // Remove # and get note letter
            const octave = parseInt(noteName.slice(-1))

            console.log(
              `Converting ${noteName} to ${note}/${octave} ${
                isSharp ? 'with sharp' : ''
              }`
            )
            return {
              keys: [`${note}/${octave}`],
              accidental: isSharp ? '#' : null
            }
          },
          redrawStaff() {
            console.log('Redrawing staff...')
            // Sauvegarder les notes avant de r√©initialiser
            const savedNotes = [...this.staff.notes]
            console.log('Saved notes before redraw:', savedNotes)

            // Clear and redraw staff
            this.initStaff()

            if (savedNotes.length > 0) {
              console.log('Drawing notes on staff:', savedNotes)
              const VF = Vex.Flow
              try {
                const notes = savedNotes.map(noteData => {
                  const staveNote = new VF.StaveNote({
                    clef: 'treble',
                    keys: noteData.keys,
                    duration: 'q'
                  })

                  // Add accidental if needed
                  if (noteData.accidental) {
                    staveNote.addModifier(
                      new VF.Accidental(noteData.accidental),
                      0
                    )
                  }

                  return staveNote
                })

                const voice = new VF.Voice({
                  num_beats: savedNotes.length,
                  beat_value: 4
                })
                voice.addTickables(notes)

                const formatter = new VF.Formatter()
                  .joinVoices([voice])
                  .format([voice], 550)
                voice.draw(this.staff.context, this.staff.stave)

                // Restaurer les notes apr√®s le redraw
                this.staff.notes = savedNotes
                console.log('Staff redrawn with notes:', savedNotes)
              } catch (error) {
                console.error('Error drawing notes:', error)
              }
            } else {
              console.log('No notes to draw')
            }
          },
          async scanBluetooth() {
            if (!navigator.bluetooth) {
              console.error('Web Bluetooth API non support√©e')
              return
            }
            try {
              this.device = await navigator.bluetooth.requestDevice({
                filters: [
                  { services: ['03b80e5a-ede8-4b33-a751-6ce34ec4c700'] } // MIDI BLE UUID
                ],
                optionalServices: ['battery_service']
              })
              const server = await this.device.gatt.connect()
              const service = await server.getPrimaryService(
                '03b80e5a-ede8-4b33-a751-6ce34ec4c700'
              )
              const characteristic = await service.getCharacteristic(
                '7772e5db-3868-4112-a1a9-f2669d106bf3'
              )
              await characteristic.startNotifications()
              characteristic.addEventListener(
                'characteristicvaluechanged',
                event => {
                  const value = event.target.value
                  // D√©codage du message MIDI BLE
                  this.parseMidiBLE(value)
                }
              )
              this.bluetoothConnected = true
            } catch (e) {
              console.error('Erreur Bluetooth: ' + e)
            }
          },
          // D√©codage des messages MIDI BLE
          parseMidiBLE(dataView, isReplay = false) {
            // Debug : affichage du contenu brut du paquet
            let arr = []
            for (let k = 0; k < dataView.byteLength; k++)
              arr.push(dataView.getUint8(k))
            console.log(`MIDI BLE ${isReplay ? 'replay ' : ''}packet:`, arr)

            // Enregistrer les donn√©es brutes si l'enregistrement est actif (et pas en rejeu)
            if (this.isRecording && !isReplay) {
              const timestamp = Date.now() - this.recordingStartTime
              this.recordingData.push({
                timestamp: timestamp,
                data: arr
              })
            }

            // Nouveau parsing : chaque paquet fait 5 octets
            if (arr.length === 5) {
              const status = arr[2] // Le vrai status MIDI est √† l'index 2
              const note = arr[3] // La note est √† l'index 3
              const velocity = arr[4] // La v√©locit√© est √† l'index 4
              console.log(
                'status:',
                status,
                'note:',
                note,
                'velocity:',
                velocity
              )
              if (status >= 0x80 && status <= 0xef) {
                // Note On
                if (
                  status === 144 &&
                  velocity > 0 &&
                  note < 128 &&
                  velocity < 128
                ) {
                  const noteName = this.noteName(note)
                  this.addNoteToStaff(noteName)
                  console.log(
                    `Note ON ${isReplay ? 'replayed' : 'detected'}:`,
                    noteName
                  )
                }
                // Note Off
                if (status === 128) {
                  console.log(
                    `Note OFF ${isReplay ? 'replayed' : 'detected'}:`,
                    this.noteName(note)
                  )
                }
              }
            }
          },
          noteName(n) {
            const notes = [
              'C',
              'C#',
              'D',
              'D#',
              'E',
              'F',
              'F#',
              'G',
              'G#',
              'A',
              'A#',
              'B'
            ]
            const octave = Math.floor(n / 12) - 1
            return notes[n % 12] + octave
          },

          // === ENREGISTREMENT ===
          startRecording() {
            this.isRecording = true
            this.recordingData = []
            this.recordingStartTime = Date.now()
            this.recordingDuration = 0

            // Timer pour afficher la dur√©e
            this.recordingTimer = setInterval(() => {
              this.recordingDuration = Math.floor(
                (Date.now() - this.recordingStartTime) / 1000
              )
            }, 1000)

            console.log('Enregistrement d√©marr√©')
          },

          async stopRecording() {
            this.isRecording = false
            clearInterval(this.recordingTimer)

            if (this.recordingData.length === 0) {
              alert('Aucune donn√©e enregistr√©e !')
              return
            }

            // Demander le nom de la cassette
            const cassetteName = prompt(
              'Nom de la cassette :',
              `Cassette_${new Date()
                .toISOString()
                .slice(0, 19)
                .replace(/[:-]/g, '')}`
            )

            if (!cassetteName) {
              console.log('Enregistrement annul√©')
              return
            }

            try {
              const response = await fetch(
                'http://localhost:4567/api/cassettes',
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json'
                  },
                  body: JSON.stringify({
                    name: cassetteName,
                    data: this.recordingData
                  })
                }
              )

              const result = await response.json()

              if (response.ok) {
                alert(`Cassette "${cassetteName}" sauvegard√©e avec succ√®s !`)
                this.loadCassettesList() // Recharger la liste
              } else {
                alert(`Erreur: ${result.error}`)
              }
            } catch (error) {
              console.error('Erreur lors de la sauvegarde:', error)
              alert('Erreur lors de la sauvegarde de la cassette')
            }

            console.log(
              `Enregistrement arr√™t√©. ${this.recordingData.length} messages enregistr√©s`
            )
          },

          // === GESTION DES CASSETTES ===
          async loadCassettesList() {
            try {
              const response = await fetch(
                'http://localhost:4567/api/cassettes'
              )
              if (response.ok) {
                this.cassettes = await response.json()
                console.log('Cassettes charg√©es:', this.cassettes)
              } else {
                console.error('Erreur lors du chargement des cassettes')
              }
            } catch (error) {
              console.error('Erreur lors du chargement des cassettes:', error)
            }
          },

          // === REJEU ===
          async replayCassette() {
            if (!this.selectedCassette) return

            this.isReplaying = true

            try {
              // Charger les donn√©es de la cassette
              const response = await fetch(
                `http://localhost:4567/${this.selectedCassette}`
              )
              const cassette = await response.json()

              console.log(`D√©but du rejeu de la cassette: ${cassette.name}`)
              console.log(`${cassette.data.length} messages √† rejouer`)

              // Vider la partition avant le rejeu
              this.staff.notes = []
              this.redrawStaff()

              // Rejouer chaque message avec le bon timing
              for (let i = 0; i < cassette.data.length; i++) {
                const message = cassette.data[i]

                // Attendre le bon moment
                if (i > 0) {
                  const delay =
                    message.timestamp - cassette.data[i - 1].timestamp
                  if (delay > 0) {
                    await new Promise(resolve => setTimeout(resolve, delay))
                  }
                }

                // Simuler la r√©ception du message MIDI
                const uint8Array = new Uint8Array(message.data)
                const dataView = new DataView(uint8Array.buffer)
                this.parseMidiBLE(dataView, true) // true = mode rejeu
              }

              console.log('Rejeu termin√©')
            } catch (error) {
              console.error('Erreur lors du rejeu:', error)
              alert('Erreur lors du rejeu de la cassette')
            }

            this.isReplaying = false
          }
        }
      }
    </script>
  </body>
</html>
