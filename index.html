<!DOCTYPE html>
<html lang="fr" x-data="midiApp()">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Piano Trainer</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css"
    />
    <script src="https://unpkg.com/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script
      defer
      src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"
    ></script>
  </head>
  <body>
    <main class="container">
      <button
        @click="scanBluetooth"
        x-text="'Scanner Bluetooth MIDI'"
        x-show="!bluetoothConnected"
        style="margin-left: 1em"
      ></button>
      <div x-show="bluetoothConnected">
        <div
          id="staff"
          style="
            margin: 20px 0;
            background-color: white;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
          "
        ></div>
      </div>
    </main>
    <script>
      function midiApp() {
        return {
          bluetoothConnected: false,
          device: null,
          staff: null,
          init() {
            this.initStaff()
          },
          initStaff() {
            const VF = Vex.Flow
            const div = document.getElementById('staff')
            div.innerHTML = '' // Clear previous staff
            const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG)
            renderer.resize(600, 200)
            const context = renderer.getContext()

            this.staff = {
              renderer,
              context,
              stave: new VF.Stave(10, 40, 580),
              notes: []
            }

            this.staff.stave.addClef('treble').addTimeSignature('4/4')
            this.staff.stave.setContext(context).draw()
          },
          addNoteToStaff(noteName) {
            console.log('Adding note to staff:', noteName)
            // Convert note name (like "C3") to VexFlow format
            const vexNote = this.convertToVexFlowNote(noteName)
            this.staff.notes.push(vexNote)
            console.log('Current staff notes:', this.staff.notes)

            // Keep only last 8 notes to fit on staff
            if (this.staff.notes.length > 8) {
              this.staff.notes.shift()
            }

            this.redrawStaff()
          },
          convertToVexFlowNote(noteName) {
            // Convert "C#4" to VexFlow format
            const isSharp = noteName.includes('#')
            let note = noteName.replace('#', '').slice(0, -1).toLowerCase() // Remove # and get note letter
            const octave = parseInt(noteName.slice(-1))

            console.log(
              `Converting ${noteName} to ${note}/${octave} ${
                isSharp ? 'with sharp' : ''
              }`
            )
            return {
              keys: [`${note}/${octave}`],
              accidental: isSharp ? '#' : null
            }
          },
          redrawStaff() {
            console.log('Redrawing staff...')
            // Sauvegarder les notes avant de réinitialiser
            const savedNotes = [...this.staff.notes]
            console.log('Saved notes before redraw:', savedNotes)

            // Clear and redraw staff
            this.initStaff()

            if (savedNotes.length > 0) {
              console.log('Drawing notes on staff:', savedNotes)
              const VF = Vex.Flow
              try {
                const notes = savedNotes.map(noteData => {
                  const staveNote = new VF.StaveNote({
                    clef: 'treble',
                    keys: noteData.keys,
                    duration: 'q'
                  })

                  // Add accidental if needed
                  if (noteData.accidental) {
                    staveNote.addModifier(
                      new VF.Accidental(noteData.accidental),
                      0
                    )
                  }

                  return staveNote
                })

                const voice = new VF.Voice({
                  num_beats: savedNotes.length,
                  beat_value: 4
                })
                voice.addTickables(notes)

                const formatter = new VF.Formatter()
                  .joinVoices([voice])
                  .format([voice], 550)
                voice.draw(this.staff.context, this.staff.stave)

                // Restaurer les notes après le redraw
                this.staff.notes = savedNotes
                console.log('Staff redrawn with notes:', savedNotes)
              } catch (error) {
                console.error('Error drawing notes:', error)
              }
            } else {
              console.log('No notes to draw')
            }
          },
          async scanBluetooth() {
            if (!navigator.bluetooth) {
              console.error('Web Bluetooth API non supportée')
              return
            }
            try {
              this.device = await navigator.bluetooth.requestDevice({
                filters: [
                  { services: ['03b80e5a-ede8-4b33-a751-6ce34ec4c700'] } // MIDI BLE UUID
                ],
                optionalServices: ['battery_service']
              })
              const server = await this.device.gatt.connect()
              const service = await server.getPrimaryService(
                '03b80e5a-ede8-4b33-a751-6ce34ec4c700'
              )
              const characteristic = await service.getCharacteristic(
                '7772e5db-3868-4112-a1a9-f2669d106bf3'
              )
              await characteristic.startNotifications()
              characteristic.addEventListener(
                'characteristicvaluechanged',
                event => {
                  const value = event.target.value
                  // Décodage du message MIDI BLE
                  this.parseMidiBLE(value)
                }
              )
              this.bluetoothConnected = true
            } catch (e) {
              console.error('Erreur Bluetooth: ' + e)
            }
          },
          // Décodage des messages MIDI BLE
          parseMidiBLE(dataView) {
            // Debug : affichage du contenu brut du paquet
            let arr = []
            for (let k = 0; k < dataView.byteLength; k++)
              arr.push(dataView.getUint8(k))
            console.log('MIDI BLE packet:', arr)

            // Nouveau parsing : chaque paquet fait 5 octets
            if (arr.length === 5) {
              const status = arr[2] // Le vrai status MIDI est à l'index 2
              const note = arr[3] // La note est à l'index 3
              const velocity = arr[4] // La vélocité est à l'index 4
              console.log(
                'status:',
                status,
                'note:',
                note,
                'velocity:',
                velocity
              )
              if (status >= 0x80 && status <= 0xef) {
                // Note On
                if (
                  status === 144 &&
                  velocity > 0 &&
                  note < 128 &&
                  velocity < 128
                ) {
                  const noteName = this.noteName(note)
                  this.addNoteToStaff(noteName)
                  console.log('Note ON detected:', noteName)
                }
                // Note Off
                if (status === 128) {
                  console.log('Note OFF detected:', this.noteName(note))
                }
              }
            }
          },
          noteName(n) {
            const notes = [
              'C',
              'C#',
              'D',
              'D#',
              'E',
              'F',
              'F#',
              'G',
              'G#',
              'A',
              'A#',
              'B'
            ]
            const octave = Math.floor(n / 12) - 1
            return notes[n % 12] + octave
          }
        }
      }
      window.addEventListener('beforeunload', () => {
        const app =
          document.querySelector('html').__x &&
          document.querySelector('html').__x.$data
        if (app && app.device && app.device.gatt && app.device.gatt.connected) {
          app.device.gatt.disconnect()
        }
      })
    </script>
  </body>
</html>
